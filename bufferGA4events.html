<!-- 
    Using Buffered gpt.js events initially. 
    In the case rendered size is 1x1, rely on prebid.js events and find the actual size rendered.
-->

<script>
(function () {
  // ======= CONFIG =======
  const DEBUG = window.ayManagerEnv.debug.flags[0] === 'true' || false; // set to false to silence all logs, or manually override

  // ======= tiny logger =======
  function log(){ if (DEBUG && window.console) console.log.apply(console, arguments); }

  // ======= attach once =======
  if (window.__SN_GPT_PREBID_BUFFER_ATTACHED__) return;
  window.__SN_GPT_PREBID_BUFFER_ATTACHED__ = true;

  // ======= public surface =======
  // Primary namespace is now window.stepnetwork (lowercase) to reduce collisions.
  // Backward compatibility: window.SN still points to the same object if previously used.
  window.stepnetwork = window.stepnetwork || {};
  const SN = window.stepnetwork; // internal reference stays SN for minimal code changes
  // Legacy alias (do not overwrite an existing distinct object)
  if (!window.SN) {
    window.SN = SN;
  }

  SN.gptEvents = [];          // raw GPT events
  SN.pbEvents  = [];          // raw Prebid events
  SN.flush     = flush;       // callable anytime, returns summary
  SN.dump      = () => ({ gpt: SN.gptEvents.slice(), pb: SN.pbEvents.slice() });

  // ======= rules config =======
  const TOPSCROLL_TOKEN = 'div-gpt-ad-topscroll';
  const INTERSTITIAL_TOKEN = 'interstitial';
  const ALLOWED_MIDSCROLL_SIZES = [
    [300, 240],
    [300, 210],
    [970, 570],
    [970, 550],
    [970, 540]
  ];

  // ======= stubs (intentionally empty; log when DEBUG) =======
  function topscrollEvent(payload)    { log('[SN][Topscroll Event]', payload); }
  function interstitialEvent(payload) { log('[SN][Interstitial Event]', payload); }
  function midscrollEvent(payload)    { log('[SN][Midscroll Event]', payload); }

  // ======= utils =======
  const now = () => (performance && performance.now) ? Math.round(performance.now()) : Date.now();
  const sizeEq = (a,b) => Array.isArray(a)&&Array.isArray(b)&&a[0]===b[0]&&a[1]===b[1];
  const is11   = (a) => Array.isArray(a) && a[0] === 1 && a[1] === 1;
  const toStr  = (a) => Array.isArray(a) ? `${a[0]}x${a[1]}` : null;
  const inAllow = (a) => ALLOWED_MIDSCROLL_SIZES.some(s => sizeEq(s,a));

  function normSlot(ev) {
    const slot = ev.slot;
    return {
      path: slot && slot.getAdUnitPath ? slot.getAdUnitPath() : '',
      elId:  slot && slot.getSlotElementId ? slot.getSlotElementId() : ''
    };
  }

  // If Prebid adUnitCode !== GPT element id, adapt this mapping.
  function mapAdUnitCodeToElementId(adUnitCode) {
    return adUnitCode || '';
  }

  // ======= capture GPT events =======
  window.googletag = window.googletag || { cmd: [] };
  log('[SN][Attach] registering GPT + Prebid buffersâ€¦');

  googletag.cmd.push(function () {
    const pubads = googletag.pubads();

    function recordGPT(type, e) {
      const { path, elId } = normSlot(e);
      const size = Array.isArray(e.size) ? e.size : null;
      const entry = {
        t: now(),
        type,
        path: path || null,
        elId:  elId  || null,
        isEmpty: !!e.isEmpty,
        size,
        size_str: toStr(size),
        lineItemId: e.lineItemId || null,
        creativeId: e.creativeId || null,
        advertiserId: e.advertiserId || null,
        campaignId: e.campaignId || null,
        serviceName: e.serviceName || null
      };
      SN.gptEvents.push(entry);
      log(`[SN][GPT][${type}]`, entry);
    }

    pubads.addEventListener('slotRequested',        (e) => recordGPT('slotRequested', e));
    pubads.addEventListener('slotResponseReceived', (e) => recordGPT('slotResponseReceived', e));
    pubads.addEventListener('slotRenderEnded',      (e) => recordGPT('slotRenderEnded', e));
    pubads.addEventListener('impressionViewable',   (e) => recordGPT('impressionViewable', e));
    pubads.addEventListener('slotOnload',           (e) => recordGPT('slotOnload', e));
  });

  // ======= capture Prebid events =======
  onPrebidReady(function () {
    try {
      safeOn('adRenderSucceeded', function (ev) {
        const elId = mapAdUnitCodeToElementId(ev.adUnitCode || '');
        const size = derivePbSize(ev);
        const entry = {
          t: now(),
          type: 'adRenderSucceeded',
          elId: elId || null,
          size,
          size_str: toStr(size),
          adUnitCode: ev.adUnitCode || null,
          bidder: ev.bidder || ev.bidderCode || null,
          adId: ev.adId || null
        };
        SN.pbEvents.push(entry);
        log('[SN][PB][adRenderSucceeded]', entry);
      });

      safeOn('bidWon', function (ev) {
        const elId = mapAdUnitCodeToElementId(ev.adUnitCode || '');
        const size = derivePbSize(ev);
        const entry = {
          t: now(),
          type: 'bidWon',
          elId: elId || null,
          size,
          size_str: toStr(size),
          adUnitCode: ev.adUnitCode || null,
          bidder: ev.bidder || ev.bidderCode || null,
          adId: ev.adId || null
        };
        SN.pbEvents.push(entry);
        log('[SN][PB][bidWon]', entry);
      });
    } catch (e) {
      log('[SN][PB][attach_error]', e);
    }
  });

  function derivePbSize(ev) {
    if (Array.isArray(ev.size)) return ev.size;
    if (ev.width && ev.height)  return [Number(ev.width), Number(ev.height)];
    if (typeof ev.size === 'string' && ev.size.includes('x')) {
      const [w,h] = ev.size.split('x'); const W = parseInt(w,10), H = parseInt(h,10);
      if (Number.isFinite(W) && Number.isFinite(H)) return [W,H];
    }
    return null;
  }

  function onPrebidReady(cb) {
    const tryNow = () => (window.pbjs && typeof pbjs.onEvent === 'function') ? (cb(), true) : false;
    if (tryNow()) return;
    let n = 0; const timer = setInterval(() => { n++; if (tryNow() || n > 50) clearInterval(timer); }, 100);
  }
  function safeOn(evName, handler) {
    try { pbjs.onEvent(evName, handler); } catch (e) { /* ignore */ }
  }

  // ======= evaluation helpers =======
  function effectiveSizeForRender(render) {
    // Use GPT size unless null/1x1; then try Prebid near-in-time for same elId.
    if (Array.isArray(render.size) && !is11(render.size)) return render.size;

    const elId = render.elId || ''; const t = render.t; const WINDOW_MS = 5000;
    let best = null;

    // Prefer adRenderSucceeded
    for (let i = SN.pbEvents.length - 1; i >= 0; i--) {
      const ev = SN.pbEvents[i];
      if (ev.elId !== elId) continue;
      if (ev.type !== 'adRenderSucceeded') continue;
      if (ev.size && Math.abs(ev.t - t) <= WINDOW_MS) { best = ev; break; }
    }
    // Fallback: bidWon
    if (!best) {
      for (let i = SN.pbEvents.length - 1; i >= 0; i--) {
        const ev = SN.pbEvents[i];
        if (ev.elId !== elId) continue;
        if (ev.type !== 'bidWon') continue;
        if (ev.size && Math.abs(ev.t - t) <= WINDOW_MS) { best = ev; break; }
      }
    }
    return best ? best.size : render.size; // may still be null
  }

  function evaluate(events) {
    const renders = events.filter(e => e.type === 'slotRenderEnded' && !e.isEmpty);

    const enriched = renders.map(r => {
      const eff = effectiveSizeForRender(r);
      return { ...r, effectiveSize: eff, effectiveSizeStr: toStr(eff) };
    });

    // topscroll: rendered, regardless of size
    const topscroll = enriched.filter(e =>
      (e.path && e.path.toLowerCase().includes('topscroll')) ||
      (e.elId && e.elId.includes(TOPSCROLL_TOKEN))
    );

    // interstitial: rendered (or onload) regardless of size
    const interstitialRendered = enriched.filter(e =>
      e.path && e.path.toLowerCase().includes(INTERSTITIAL_TOKEN)
    );
    const interstitialOnload = events.filter(e =>
      e.type === 'slotOnload' &&
      e.path && e.path.toLowerCase().includes(INTERSTITIAL_TOKEN)
    );
    const interstitial = interstitialRendered.concat(interstitialOnload);

    // midscroll: by effective size
    const midscroll = enriched.filter(e => Array.isArray(e.effectiveSize) && inAllow(e.effectiveSize));

    return { topscroll, interstitial, midscroll, enriched };
  }

  // ======= flush (re-usable, returns summary) =======
  function flush(reason = 'manual', opts = {}) {
    const { clear = false } = opts;
    const summary = evaluate(SN.gptEvents);

    // call stubs
    if (summary.topscroll.length)    topscrollEvent({ matches: summary.topscroll });
    if (summary.interstitial.length) interstitialEvent({ matches: summary.interstitial });
    if (summary.midscroll.length)    midscrollEvent({ matches: summary.midscroll });

    log('[SN][Flush]', {
      reason,
      counts: {
        topscroll: summary.topscroll.length,
        interstitial: summary.interstitial.length,
        midscroll: summary.midscroll.length
      }
    });

    if (clear) {
      SN.gptEvents.length = 0;
      SN.pbEvents.length  = 0;
      log('[SN][Flush][cleared]');
    }

    return summary; // so you can do: const r = SN.flush('manual'); console.log(r);
  }

  // ======= ONLY flush on pagehide (modern unload) =======
  window.addEventListener('pagehide', () => SN.flush('pagehide', { clear:true }));
})();
</script>
