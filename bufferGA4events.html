<script>
(function () {
  const DEBUG = window.ayManagerEnv.debug.flags[0] === 'true' || false;

  function log(){ if (DEBUG && window.console) console.log.apply(console, arguments); }

  if (window.__SN_GPT_PREBID_BUFFER_ATTACHED__) return;
  window.__SN_GPT_PREBID_BUFFER_ATTACHED__ = true;

  window.stepnetwork = window.stepnetwork || {};

  function trackAdEvent(kind, payload) {
    /* 
    
    GA4 invoke or function for event here
    
    */

    if (DEBUG) log('[SN][Track]', kind, payload);
  }
  window.stepnetwork.trackAdEvent = trackAdEvent;

  const TOPSCROLL_TOKEN = 'div-gpt-ad-topscroll';
  const INTERSTITIAL_TOKEN = 'interstitial';
  const ALLOWED_MIDSCROLL_SIZES = [[300,240],[300,210],[970,570],[970,550],[970,540]];

  const now = () => (performance && performance.now) ? Math.round(performance.now()) : Date.now();
  const sizeEq = (a,b) => Array.isArray(a)&&Array.isArray(b)&&a[0]===b[0]&&a[1]===b[1];
  const is11   = (a) => Array.isArray(a) && a[0] === 1 && a[1] === 1;
  const toStr  = (a) => Array.isArray(a) ? `${a[0]}x${a[1]}` : null;
  const inAllow = (a) => ALLOWED_MIDSCROLL_SIZES.some(s => sizeEq(s,a));

  function normSlot(ev) {
    const slot = ev.slot;
    return {
      path: slot && slot.getAdUnitPath ? slot.getAdUnitPath() : '',
      elId:  slot && slot.getSlotElementId ? slot.getSlotElementId() : ''
    };
  }

  function mapAdUnitCodeToElementId(adUnitCode) {
    return adUnitCode || '';
  }

  const pbCache = Object.create(null);
  function pushPbEvent(elId, ev) {
    if (!elId) return;
    (pbCache[elId] || (pbCache[elId] = [])).push(ev);
  }

  function findCorrelatedPrebidSize(elId) {
    if (!elId) return null;
    let arr = pbCache[elId];
    if (!arr) {
      // Fuzzy fallback: find first key that includes elId or is included by elId
      const keys = Object.keys(pbCache);
      for (let k of keys) {
        if (k.includes(elId) || elId.includes(k)) { arr = pbCache[k]; break; }
      }
    }
    if (!arr || !arr.length) return null;
    // Reverse scan: prefer adRenderSucceeded over bidWon by first encountered in reverse order
    for (let i = arr.length - 1; i >= 0; i--) {
      const ev = arr[i];
      if (ev.type === 'adRenderSucceeded' && Array.isArray(ev.size)) return ev.size;
    }
    // Fallback: any bidWon with size
    for (let i = arr.length - 1; i >= 0; i--) {
      const ev = arr[i];
      if (ev.type === 'bidWon' && Array.isArray(ev.size)) return ev.size;
    }
    return null;
  }

  window.googletag = window.googletag || { cmd: [] };

  googletag.cmd.push(function () {
    const pubads = googletag.pubads();

    function buildBase(e, typeOverride) {
      const { path, elId } = normSlot(e);
      const size = Array.isArray(e.size) ? e.size : null;
      return {
        t: now(),
        type: typeOverride || e.type || null,
        path: path || null,
        elId: elId || null,
        isEmpty: !!e.isEmpty,
        size,
        size_str: toStr(size),
        lineItemId: e.lineItemId || null,
        creativeId: e.creativeId || null,
        advertiserId: e.advertiserId || null,
        campaignId: e.campaignId || null,
        serviceName: e.serviceName || null
      };
    }

    function effectiveSize(base) {
      if (Array.isArray(base.size) && !is11(base.size)) return base.size; // GPT gave real size
      if (!base.elId) return base.size; // no element id => cannot correlate
      const corr = findCorrelatedPrebidSize(base.elId);
      return corr || base.size;
    }

    function classifyAndTrack(base, gptEventName) {
      // Only evaluate on slotRenderEnded (non-empty) and slotOnload for interstitial.
      const lowerPath = (base.path || '').toLowerCase();
      const matches = [];

      if (gptEventName === 'slotRenderEnded' && !base.isEmpty) {
        // topscroll
        if (lowerPath.includes('topscroll') || (base.elId && base.elId.includes(TOPSCROLL_TOKEN))) {
          matches.push('topscroll');
        }
        // midscroll (by effective size)
        const eff = effectiveSize(base);
        if (Array.isArray(eff) && inAllow(eff)) {
          matches.push('midscroll');
          base.effectiveSize = eff;
          base.effectiveSizeStr = toStr(eff);
        }
        // interstitial
        if (lowerPath.includes(INTERSTITIAL_TOKEN)) {
          matches.push('interstitial');
        }
      } else if (gptEventName === 'slotOnload') {
        if (lowerPath.includes(INTERSTITIAL_TOKEN)) {
          matches.push('interstitial');
        }
      }

      matches.forEach(kind => trackAdEvent(kind, base));
    }

    function handleRenderLike(name) {
      return (e) => {
        const base = buildBase(e, name);
        classifyAndTrack(base, name);
      };
    }

    pubads.addEventListener('slotRenderEnded', handleRenderLike('slotRenderEnded'));
    pubads.addEventListener('slotOnload',      handleRenderLike('slotOnload'));
  });

  onPrebidReady(function () {
    try {
      safeOn('adRenderSucceeded', function (ev) {
        const elId = mapAdUnitCodeToElementId(ev.adUnitCode || '');
        const size = derivePbSize(ev);
        const entry = {
          t: now(),
          type: 'adRenderSucceeded',
          size,
          bidder: ev.bidder || ev.bidderCode || null,
          adId: ev.adId || null
        };
        pushPbEvent(elId, entry);
      });

      safeOn('bidWon', function (ev) {
        const elId = mapAdUnitCodeToElementId(ev.adUnitCode || '');
        const size = derivePbSize(ev);
        const entry = {
          t: now(),
          type: 'bidWon',
          size,
          bidder: ev.bidder || ev.bidderCode || null,
          adId: ev.adId || null
        };
        pushPbEvent(elId, entry);
      });
    } catch (e) {
    }
  });

  function derivePbSize(ev) {
    if (Array.isArray(ev.size)) return ev.size;
    if (ev.width && ev.height)  return [Number(ev.width), Number(ev.height)];
    if (typeof ev.size === 'string' && ev.size.includes('x')) {
      const [w,h] = ev.size.split('x'); const W = parseInt(w,10), H = parseInt(h,10);
      if (Number.isFinite(W) && Number.isFinite(H)) return [W,H];
    }
    return null;
  }

  function onPrebidReady(cb) {
    const tryNow = () => (window.pbjs && typeof pbjs.onEvent === 'function') ? (cb(), true) : false;
    if (tryNow()) return;
    let n = 0; const timer = setInterval(() => { n++; if (tryNow() || n > 50) clearInterval(timer); }, 100);
  }
  function safeOn(evName, handler) {
    try { pbjs.onEvent(evName, handler); } catch (e) { /* ignore */ }
  }

})();
</script>